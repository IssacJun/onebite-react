// 원시타입과 객체타입
// 값이 저장되거나 복사되는 과정이 서로 다름

// 원시타입: 값 자체로써 변수에 저장되고 복사됨(불변값: 메모리 값 수정되지 않음)
// 각 메모리 공간에 각 값을 저장하고 변수명이 이를 가리키도록
// 실제로 메모리 공간에 저장된 이 원본 데이터의 값은 변경되지 않음

// 객체타입: 값에 접근할 수 있는 참조값을 통해 변수에 저장된고 복사됨(가변값: 메모리 값 수정됨)
// 별도의 메모리 공간에 해당 객체타입의 참조값이 저장됨
// 변수명이 참조값을 가리킴, 원본데이터 아예 수정됨
// 의도치 않게 값이 수정될 수 있음 -> side effect

// 객체 타입을 복사할 때 
// 새로운 객체 생성하고 내부에 ...o1처럼 스프레드 연산자로 새로운 객체를 생성하면서
// 내부 프로퍼티만 따로 복사해야 함
// let o2 = {...o1}; // 새로운 참조값이 생성됨

// 객체의 참조값을 복사함, 원본 객체가 수정될 수 있음
let o1 = { name: "우준"};
let o2 = o1; // 얕은 복사

// 새로운 객체 생성하며 프로퍼티만 복사함, 원본 객체가 수정될 수 없음
let o3 = { name: "우준"};
let o4 = { ...o3 }; // 깊은 복사
o4.name = "가일";

// 객체 간의 비교는 참조값을 기준으로 이뤄짐
// 참조값이 서로 다른, 깊은 복사된 객체는 같지 않음
// 대신, 프로퍼티 기준으로 비교할 때 객체를 문자열로 변환해서 비교해야(JSON.stingfy())

// 배열과 함수도 사실 객체다